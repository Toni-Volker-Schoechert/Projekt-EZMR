\chapter{Praktikum}

In diesem Kapitel werden die durchgeführten Praktikumsaufgaben zur mobilen Robotik dokumentiert. 
Ziel ist es, die praktischen Arbeiten mit ROS 2 nachvollziehbar darzustellen, die Umsetzung eigener Pakete zu beschreiben und die dabei gewonnenen Erkenntnisse zu reflektieren. 
Die Aufgaben sind in einzelne Abschnitte gegliedert, die jeweils eine kurze Einleitung, die Zielsetzung, die Umsetzung und die Auswertung enthalten.

\section{ROS 2 Grundlagen und Arbeitsumgebung}
\label{sec:ros2_setup}

Für die Durchführung des Praktikums wurde eine virtuelle Maschine mit Ubuntu 22.04 und der ROS 2-Distribution \textit{Humble} \cite{macenski2022} verwendet. 
Die VM wurde speziell für den Einsatz mit ROS 2 vorbereitet, wodurch alle erforderlichen Abhängigkeiten bereits installiert waren.

Um die ROS-Umgebung bei jedem Start eines Terminals automatisch zu initialisieren, wurde folgender Befehl ausgeführt:
\begin{verbatim}
	echo "source /opt/ros/humble/setup.bash" >> ~/.bashrc
\end{verbatim}
Damit wird das Setup-Skript beim Öffnen eines neuen Terminals automatisch geladen. 
Dies erspart das manuelle Aktivieren des Arbeitsbereichs und vereinfacht die tägliche Arbeit mit ROS erheblich. \cite{ros2env}

Zur Funktionsprüfung wurde die bekannte \texttt{turtlesim}-Simulation gestartet entsprechend der Quelle \cite{turtlesim}:
\begin{verbatim}
	ros2 run turtlesim turtlesim_node
	ros2 run turtlesim turtle_teleop_key
\end{verbatim}
Die Simulation ließ sich fehlerfrei ausführen, und sämtliche Tests verliefen wie erwartet. 
Über die \texttt{turtlesim}-Beispielanwendung konnten zudem die grundlegenden Kommunikationsmechanismen von ROS 2 nachvollzogen werden. 
Dabei kommunizieren einzelne \textit{Nodes} über sogenannte \textit{Topics}, über die beispielsweise Bewegungsbefehle in Form von Geschwindigkeitsnachrichten übertragen werden. 
Diese Erkenntnisse bilden die Grundlage für die Entwicklung eigener ROS 2-Pakete in den folgenden Arbeitsschritten.

\section{Erstellung eines eigenen ROS 2-Pakets}
\label{sec:ros2_package}

In diesem Abschnitt wurde ein eigenes ROS 2-Paket erstellt, um ein Verständnis für die grundlegende Struktur und den Aufbau von ROS 2-Anwendungen zu entwickeln. 
Als Basis dient die offizielle Dokumentation zu Arbeitsbereichen und Paketen in ROS 2 \cite{ros2_workspace, ros2_package_creation, ros2_cpp_pubsub}.

\subsection{Einrichtung des Arbeitsbereichs}
\label{sub:setup_ws}

Der verwendete Arbeitsbereich (\texttt{ros2\_ws}) basiert auf der in Abschnitt \ref{sec:ros2_setup} beschriebenen Umgebung. Der folgende Setup des Arbeitsbereiches basiert sich an dem Tutorial \cite{ros2_workspace}. 
ROS 2 nutzt ein sogenanntes \textit{Underlay}- und \textit{Overlay}-Konzept: 
Das Underlay umfasst die Basisinstallation (hier die ROS 2-Distribution \textit{Humble}), 
während im Overlay eigene Pakete ergänzt werden können, ohne die Systeminstallation zu verändern. 

Zunächst wurde ein neuer Arbeitsbereich mit zugehörigem \texttt{src}-Ordner angelegt:
\begin{verbatim}
	mkdir -p ~/ros2_ws/src
\end{verbatim}
Im \texttt{src}-Ordner können die neuen Pakete angelegt werden.
Wenn ein neues Paket im \texttt{src}-Ordner angelegt wurde, kann das Overlay gebaut werden:
\begin{verbatim}
	cd ~/ros2_ws
	colcon build
\end{verbatim}

Anschließend sollte in einem neuen Terminal das Overlay gesourct werden:
\begin{verbatim}
	cd ~/ros2_ws
	source install/local_setup.bash
\end{verbatim}


\subsection{Struktur des ROS 2-Pakets}

Ein ROS 2-Paket dient der strukturierten Organisation und dem Wiederverwenden von Code. 
Es enthält für C++ folgende Elemente:
\begin{itemize}
	\item \texttt{CMakeLists.txt} – beschreibt den Build-Prozess (CMake-Konfiguration),
	\item \texttt{package.xml} – enthält Metadaten, Abhängigkeiten und Lizenzinformationen,
	\item \texttt{src/} – Quellcode-Verzeichnis,
	\item \texttt{include/} – Header-Dateien (bei größeren Projekten).
\end{itemize}

Für die Entwicklung in C++ wird das Buildsystem \texttt{ament\_cmake} verwendet, und als Build-Tool dient \texttt{colcon}.

\subsection{Erstellung des eigenen Pakets}

Das Paket \texttt{cpp\_turtle\_controller} wurde mit folgendem Befehl erzeugt:
\begin{verbatim}
	cd ~/ros2_ws/src
	ros2 pkg create --build-type ament_cmake \
	--license Apache-2.0 cpp_turtle_controller
\end{verbatim}
Damit wird automatisch die Grundstruktur des Pakets angelegt.  
In der Datei \texttt{package.xml} wurden anschließend die relevanten Abhängigkeiten ergänzt:
\begin{verbatim}
	<depend>rclcpp</depend>
	<depend>geometry_msgs</depend>
\end{verbatim}
sowie eine kurze Beschreibung und der Maintainer eingetragen.  
Alle geänderten Dateien dieses Paketes und der anderen Pakete liegen im Githup Repository zu diesem Projekt.

\subsection{Implementierung Programm}

Im Verzeichnis \texttt{src/} des neuen Pakets wurde die Datei \texttt{turtle\_square.cpp} erstellt.
Sie implementiert eine ROS 2-Node, die periodisch \texttt{geometry\_msgs/msg/Twist}-Nachrichten auf das Topic \texttt{/turtle1/cmd\_vel} publiziert,
um die Turtle in der \texttt{turtlesim}-Simulation automatisch ein Quadrat fahren zu lassen.
Die Umsetzung und Beschreibung dieses Abschnitts orientiert sich an der Quelle \cite{ros2_cpp_pubsub}.

Die Steuerung erfolgt über einen zeitbasierten Zyklus:
\begin{itemize}
	\item Für eine definierte Zeit fährt die Turtle geradeaus.
	\item Danach erfolgt eine Drehung um ca. 90°.
	\item Der Zyklus wiederholt sich kontinuierlich.
\end{itemize}
  
In Listing \ref{lst:turtle_controller} ist ein Ausschnitt des Programmcodes dargestellt, der den zentralen Steuermechanismus der Node zeigt.

Der gezeigte Abschnitt bildet das Kernstück der Anwendung:
Hier wird über eine einfache Zustandslogik (step\_) zwischen zwei Bewegungsphasen unterschieden, einer Vorwärtsbewegung und einer anschließenden Drehung um etwa 90 Grad.
Durch die wiederholte Ausführung dieser Logik entsteht die charakteristische quadratische Bewegung der Turtle in der Simulation.

Der restliche Programmaufbau (Publisher, Timer und Node-Initialisierung) folgt der Standardstruktur einer ROS 2-C++-Node und ist daher nicht im Detail dargestellt.

\begin{lstlisting}[language=C++,caption={Node zur Steuerung der turtlesim-Turtle},label={lst:turtle_controller}]
	publisher_ = this->create_publisher<geometry_msgs::msg::Twist>(
	"/turtle1/cmd_vel", 10);
	
	if (step_ < 20) {
		msg.linear.x = 0.5;   // Vorwärtsbewegung
		msg.angular.z = 0.0;
	} else if (step_ < 36) {
		msg.linear.x = 0.0;
		msg.angular.z = 1.0;  // Drehung ca. 90 Grad
	} else {
		step_ = 0;
	}
\end{lstlisting}

\subsection{Build und Test}

Nach der Implementierung wurde das Paket wie bereits allgemein in Abschnitt \ref{sub:setup_ws} beschrieben gebaut:
\begin{verbatim}
	cd ~/ros2_ws
	colcon build --packages-select cpp_turtle_controller
\end{verbatim}
 Anschließend in einem neuen Terminal wurde die \texttt{turtlesim}-Simulation gestartet und in einem separaten Terminal das Overlay mit dem neuen Paket gestartet und der Node ausgeführt.
\begin{verbatim}
	cd ~/ros2_ws
	source install/local_setup.bash
	ros2 run cpp_turtle_controller turtle_square
\end{verbatim}

\subsection{Ergebnis und Beobachtungen}

Das Ergebnis des Tests ist in Abbildung~\ref{fig:turtle_sq} dargestellt.  
Die Turtle bewegte sich wie erwartet entlang einer annähernd quadratischen Bahn.  
Aufgrund des fehlenden Positions-Feedbacks traten jedoch leichte Abweichungen in den Drehwinkeln auf, 
wodurch sich die Form des Quadrats über mehrere Zyklen leicht verzerrte.  

Insgesamt funktionierte die Steuerlogik zuverlässig, und die Bewegungssequenzen wurden korrekt ausgeführt.  
Durch die Implementierung eines zusätzlichen \textit{Subscribers}, der Positionsdaten aus der \texttt{turtlesim}-Simulation auswertet, 
könnten die auftretenden Ungenauigkeiten reduziert werden.

\begin{figure}[H]
	\centering
	\includegraphics[width=0.8\textwidth]{Bilder/turtlesim_square_1.png}
	\caption{Quadratische Fahrbewegung in der \texttt{turtlesim}-Simulation}
	\label{fig:turtle_sq}
\end{figure}

\section{Programmierung eines eigenen Roboters}
\label{sec:eigener_roboter}

Ziel dieser Aufgabe war es, den eigenen Roboter so zu programmieren, dass er über das ROS2-Topic \texttt{/cmd\_vel} Geschwindigkeitsbefehle empfangen und seine Motoren entsprechend ansteuern kann. Dazu wurde ein ESP32-Mikrocontroller verwendet, der mithilfe der Bibliothek \textit{Micro-ROS} direkt mit dem ROS2-Netzwerk kommuniziert. Der ESP32 fungiert dabei als Micro-ROS-Client und steht über eine serielle Verbindung mit dem auf dem Host-PC laufenden Micro-ROS-Agenten in Kontakt.

\subsection{Aufbau und Funktionsweise}

Die Programmierung erfolgte in der Entwicklungsumgebung \textit{PlatformIO} unter Visual Studio Code. Das auf dem ESP32 ausgeführte Programm definiert eine Node mit dem Namen \texttt{esp32\_cmd\_vel\_node}, welche zwei zentrale ROS-2-Kommunikationsobjekte beinhaltet:

\begin{itemize}
	\item einen \textbf{Subscriber} auf das Topic \texttt{/cmd\_vel} vom Typ \texttt{geometry\_msgs/msg/Twist}, über den lineare und angulare Geschwindigkeitskomponenten empfangen werden,
	\item sowie einen \textbf{Publisher} auf das Topic \texttt{/debug} vom Typ \texttt{std\_msgs/msg/String}, der zu Debug-Zwecken Status- und Bewegungsinformationen zurückmeldet.
\end{itemize}

Im Callback \texttt{cmd\_vel\_callback()} werden die empfangenen Geschwindigkeitsdaten in differenzielle Motorbefehle übersetzt. Hierfür wird eine einfache Differentialsteuerung verwendet, bei der aus der linearen und der Winkelgeschwindigkeit die Drehzahlen der linken und rechten Motoren berechnet werden. Die resultierenden Werte werden über eine UART-Schnittstelle an die Motorsteuerung gesendet. Zusätzlich werden die berechneten Werte als Textnachricht über das Topic \texttt{/debug} publiziert, um die Funktionsweise während der Laufzeit überwachen zu können.

Nachfolgend ist ein Ausschnitt des zentralen Steuerteils dargestellt:

\begin{lstlisting}[language=C++, caption={Ausschnitt des Micro-ROS-Programms auf dem ESP32}, label={lst:esp32_code}]
	void cmd_vel_callback(const void * msgin) {
		const geometry_msgs__msg__Twist * received_msg = 
		(const geometry_msgs__msg__Twist *)msgin;
		
		float linear = received_msg->linear.x;
		float angular = received_msg->angular.z;
		
		int16_t left_motor = linear - angular;
		int16_t right_motor = linear + angular;
		
		left_motor = constrain(left_motor, -100, 100);
		right_motor = constrain(right_motor, -100, 100);
		
		uint8_t left_dir  = (left_motor >= 0) ? 1 : 0;
		uint8_t right_dir = (right_motor >= 0) ? 0 : 1;
		
		sendMotorCommand(1, 0, left_dir, abs(left_motor));
		sendMotorCommand(2, 0, right_dir, abs(right_motor));
	}
\end{lstlisting}

\subsection{Durchführung}

Nach dem Hochladen des Programms auf den ESP32 wurde der Micro-ROS-Agent auf dem Host-Rechner gestartet und der Mikrocontroller über USB erneut verbunden.  
Nach erfolgreicher Verbindung meldete sich der ESP32 im ROS-2-Netzwerk als Node an und begann, die über \texttt{/cmd\_vel} gesendeten Bewegungsbefehle auszuwerten.  
Zur Überprüfung der Funktionalität konnten über die folgenden Befehle in einem Terminal Testnachrichten gesendet und Rückmeldungen angezeigt werden:

\begin{verbatim}
ros2 topic pub /cmd_vel geometry_msgs/msg/Twist \
"{linear: {x: 1.0}, angular: {z: 0.0}}"\part{	ros2 topic pub /cmd_vel geometry_msgs/msg/Twist "{linear: {x: 1.0}, angular: {z: 0.0}}"}
	ros2 topic echo /debug
\end{verbatim}

Anschließend wurde das zuvor in Abschnitt \ref{sec:ros2_package} erstellte ROS-Paket, das ursprünglich die \textit{turtlesim}-Schildkröte steuerte, erneut ausgeführt.  
Damit der reale Roboter anstelle der Simulation auf dieselben Bewegungsbefehle reagieren konnte, musste im Programmcode von \texttt{turtle\_square} das Topic, auf das die Befehle publiziert werden, von \texttt{/turtle1/cmd\_vel} auf das allgemeine \texttt{/cmd\_vel} geändert werden.  
Nach dieser Anpassung reagierte der Roboter auf die veröffentlichten Bewegungsbefehle des \texttt{turtle\_square}-Nodes und führte die gleiche Bewegungssequenz aus wie in der Simulation.


\subsection{Beobachtungen}

Der Roboter führte die Bewegungssequenz grundsätzlich wie erwartet aus: geradeaus fahren, anschließend drehen und erneut geradeaus fahren.  
Auffällig war jedoch, dass die Drehungen kleiner ausfielen als in der Simulation.  
Anstelle 90° Drehungen, wie bei einem Quadrat, waren sie nur halb so groß , wodurch die Trajektorie eher einem unregelmäßigen Polygon entsprach.  

Zeitweise zeigte der Roboter kurzzeitiges Zittern oder Oszillationen, was auf minimale Kommunikationsverzögerungen oder Jitter zwischen Agent und ESP32 hinweist.  
Trotz dieser Störungen blieb der Roboter weitgehend stabil und driftete nicht signifikant vom Ausgangsbereich ab.

\subsection{Diskussion und Fazit}

Die Abweichungen zwischen der Simulation und dem realen Verhalten lassen sich durch mehrere Faktoren erklären:

\begin{itemize}
	\item \textbf{Open-Loop-Steuerung:} Das Programm nutzt kein Sensorfeedback, sodass keine Korrektur von Abweichungen erfolgen kann.
	\item \textbf{Physikalische Unterschiede:} Reibung, Trägheit und Motordynamik wirken in der Realität, aber nicht in der idealisierten Simulation.
	\item \textbf{Quantisierung:} Durch die ganzzahlige Verarbeitung (\texttt{uint8\_t}) werden kleine Geschwindigkeitsänderungen gerundet.
\end{itemize}

Der Versuch zeigte, dass die Integration eines ESP32 mit Micro-ROS erfolgreich funktionierte und der Roboter über ROS2-Topics gesteuert werden konnte.  
Gleichzeitig verdeutlichte er die Grenzen einer offenen Steuerung ohne Rückmeldung: kleine Abweichungen summieren sich über die Zeit und führen zu merkbaren Differenzen zwischen Soll- und Istbewegung.  

Eine mögliche Verfeinerung dieses Programms bestünde darin, Sensordaten (z.B. IMU) rückzuführen, um die ausgeführten Bewegungen präziser steuern zu können. Auf diese Weise ließe sich die geplante Quadratbahn exakter abfahren. Im Rahmen dieser Aufgabe wurde jedoch bewusst auf Sensorfeedback verzichtet, um den Fokus auf die grundlegende Micro-ROS-Kommunikation und die Umsetzung der offenen Steuerung zu legen.


\section{Erweiterung durch Sensorik und eigenes Projekt}

Nachdem die Grundbewegung des Roboters funktionierte, sollte im Rahmen der Aufgabe 2.4
mindestens ein Sensor des Roboters in ein eigenes Projekt integriert werden. Ziel war es,
den Sensor mithilfe des ESP32 auszulesen, die Messwerte in das ROS\,2-Netzwerk zu
publizieren und auf dem Host-PC weiterzuverarbeiten.

In diesem Projekt werden die beiden \emph{Bumper-Sensoren} des Roboters sowie der
\emph{Buzzer} genutzt. Die Bumper dienen als einfache kollisionsbasierte Hinderniserkennung und lösen abhängig von der Fahrtrichtung links oder rechts ein eigenes Verhalten aus. Der
Buzzer wird dabei genutzt, um akustische Rückmeldungen zu erzeugen.

Der vollständige Quellcode für ESP32 (micro-ROS) und den ROS-2-Node befindet sich im
zugehörigen GitHub-Repository.

\subsection{Aufbau des Systems}

Der Roboter verfügt über zwei vorne montierte Bumper-Schalter (links und rechts),
welche im ESP32 als digitale Eingänge mit \texttt{INPUT\_PULLUP} konfiguriert wurden.
Ein gedrückter Bumper erzeugt ein \texttt{LOW}-Signal. Beide Sensoren werden nicht per
Interrupt, sondern über einen regelmäßig laufenden micro-ROS-Timer (50 ms) abgefragt.

Zusätzlich wurde der vorhandene Buzzer an einem PWM-fähigen Pin angebunden. Dieser
kann über das Topic \texttt{/buzzer} mit einer Frequenz angesteuert werden, sodass der Roboter
akustisch auf erkannte Hindernisse reagiert.

Auf dem Host-PC wurde ein eigener ROS-2-Node implementiert, der die Bumper-Signale
auswertet und daraufhin Bewegungsbefehle über \texttt{/cmd\_vel} an den Roboter sendet. Somit
entsteht eine einfache Hindernisvermeidung.

\subsection{Funktionsweise des ESP32-Programms}

Der ESP32 übernimmt drei zentrale Aufgaben:

\begin{enumerate}
	\item \textbf{Auslesen der Bumper-Sensoren}
	\begin{itemize}
		\item Polling im 50 ms-Takt
		\item Software-Debouncing zur Unterdrückung von Prellen
		\item Veröffentlichung von \texttt{/bumper/left} und \texttt{/bumper/right} als \texttt{std\_msgs/Bool}
	\end{itemize}
	
	\item \textbf{Ansteuerung der Motoren über \texttt{/cmd\_vel}}
	\begin{itemize}
		\item differentialbasierte Umsetzung der Twist-Nachricht
		\item Begrenzung und Umrechnung der Werte auf das serielle Motorprotokoll
		\item Debug-Ausgabe über \texttt{/debug}
	\end{itemize}
	
	\item \textbf{Buzzer-Steuerung über \texttt{/buzzer}}
	\begin{itemize}
		\item PWM-Signal mit frei wählbarer Frequenz
		\item automatisches Abschalten nach Ablauf der Dauer
	\end{itemize}
\end{enumerate}

Durch die Kombination dieser Funktionen wird der ESP32 zu einem reinen
micro-ROS-Sensorknoten, während die höhere Logik auf dem PC ausgeführt wird.

\subsection{Funktionsweise des ROS2-Nodes auf dem Host-PC}

Der ROS-2-Node \texttt{bumper\_react} übernimmt die komplette Entscheidungslogik.  
Sein Verhalten lässt sich wie folgt zusammenfassen:

\begin{itemize}
	\item Standardzustand: \textbf{geradeaus fahren}
	\item Wenn der linke Bumper ausgelöst wird:
	\begin{itemize}
		\item ein höherer Ton wird über \texttt{/buzzer} gesendet,
		\item der Roboter fährt kurz rückwärts,
		\item anschließend dreht er nach rechts,
		\item danach setzt er die Vorwärtsfahrt fort.
	\end{itemize}
	
	\item Wenn der rechte Bumper ausgelöst wird:
	\begin{itemize}
		\item ein tiefer Ton wird ausgelöst,
		\item kurze Rückwärtsfahrt,
		\item Drehung nach links,
		\item anschließend Weiterfahrt.
	\end{itemize}
	
	\item Zu beginn der Rückwärtsfahrt wird der Buzzer zusätzlich mehrfach aktiviert, 
	um das Manöver akustisch zu signalisieren.
\end{itemize}

Die Steuerung erfolgt über einen Zustandsautomaten mit den
Zuständen \texttt{FORWARD}, \texttt{REVERSE}, \texttt{STOP} und \texttt{TURN}.  
Ein 200 ms-Timer führt die Bewegungslogik aus, wobei mehrfach hintereinander
Bewegungsbefehle mit einer Schleife gesendet werden, um Übertragungsverluste zu kompensieren.

Beim Beenden des Programms wird automatisch ein Stopp-Befehl gesendet.

\subsection{Beobachtungen und Herausforderungen}

Während der praktischen Versuche zeigte sich Folgendes:

\begin{itemize}
	\item Die Hinderniserkennung über die Bumper funktionierte zuverlässig.
	\item Der Debounce-Mechanismus war notwendig, da die Bumper ohne Entprellung
	gelegentlich mehrfach auslösten.
	\item Die Bewegungsabläufe (\emph{rückwärts, drehen, vorwärts}) funktionierten im Normalfall korrekt.
	\item Es kam vereinzelt vor, dass der Roboter von den vorgesehenen Bewegungen
	abwich. Dies hängt vermutlich mit der Mikro-ROS-Übertragung zusammen:
	\begin{itemize}
		\item einzelne \texttt{/cmd\_vel}-Nachrichten gingen verloren,
		\item Motorbefehle wurden manchmal verzögert verarbeitet.
	\end{itemize}
	\item Durch die Mehrfachübermittlung von Bewegungsbefehlen innerhalb der
	Zustandsmaschine konnten diese Fehler deutlich reduziert werden.
\end{itemize}

\subsection{Fazit}

Das Projekt zeigt, wie sich einfache Sensordaten (Bumper) nutzen lassen, um ein
autonomes Verhalten zu erzeugen. Die Trennung zwischen
ESP32 als micro-ROS-Sensor-/Aktorknoten und PC-seitiger Logik hat sich klar bewährt. Gleichzeitig verdeutlichen die Versuche, dass ohne Rückkanäle oder
Positionssensorik kleine Übertragungs- oder Timingfehler dazu führen können, dass die
Trajektorie des Roboters nicht vollständig reproduzierbar ist.

Das vorgestellte System bietet jedoch eine robuste und erweiterbare Grundlage, um
weitere Sensordaten oder komplexere Reaktionen zu integrieren.

\section{Arbeiten mit dem TurtleBot 4}

In diesem Abschnitt wird die praktische Arbeit mit dem professionellen mobilen Roboter \textit{TurtleBot 4} dokumentiert.
Der TurtleBot 4 basiert auf ROS,2 und stellt zahlreiche Sensoren, Aktoren sowie Navigations- und SLAM-Funktionalitäten bereit.
Ziel der Aufgabe war es, die grundlegenden Funktionsweisen des Roboters kennenzulernen, die SLAM- und Navigationspipeline praktisch zu erproben und anschließend ein eigenes kleines ROS-2-Programm auf den TurtleBot anzupassen. Wir orientieren uns in diesem Abschnitt an dem Benutzerhandbuch zum Turtlebot4 \cite{turtlebot4_user_manual}

\subsection{Aufgabe 1}

Ziel dieser Aufgabe ist es, eine Verbindung mit dem Turtlebot herzustellen und diesen manuell zu bewegen. Die Verbindung zwischen Rechner und Turtlebot wurde dabei automatisch hergestellt. Um die manuelle Bewegung zu ermöglichen, wurde zuerst der Befehl
\begin{verbatim}
	ros2 run teleop_twist_keyboard teleop_twist_keyboard
\end{verbatim}
ausgeführt. Dadurch öffnet sich im Terminal eine Auflistung an einfachen Eingaben, durch welche der Turtlebot über das Topic cmd\_vel gesteuert werden kann.

\subsection{Aufgabe 2}
Als zweiter Teil des Praktikums sollen mit dem Turtlebot visuelle Daten eingelesen und ausgegeben werden. Dafür wird das Programm RViz verwendet. Nach der Ausführung von \begin{verbatim}
	ros2 launch turtlebot4_viz view_robot.launch.py
\end{verbatim}
wird das Programm gestartet und es wird ausgehend vom Sichtfeld des Roboters bereits eine Karte aufgezeichnet. 

\subsection{Aufgabe 3}

Hier soll eine gesamte Karte Aufgezeichnet und abgespeichert werden. Dafür wird der Roboter nach Aufgabe 2 manuell weiterbewegt, bis er alle Hindernisse erkannt hat. Das kann visuell mit RViz überprüft werden, diese Karte ist in Abbildung \ref{fig:map} zu sehen.
\begin{figure}
	\centering
	\includegraphics[width=\textwidth]{Bilder/MAP.png}	
	\caption{Mit Rviz erzeugte Karte}
	\label{fig:map}
\end{figure}


 Dabei kam es beim ersten Versuch dazu, dass eine nicht existierende Wand eingezeichnet wurde. Diese enstand vermutlich durch den Blindspot hinter dem Roboter, während sich dieser noch in der Startposition auf der Ladestation befand.

Das Abspeichern der Karte erfolgt daraufhin mit 
\begin{verbatim}
	ros2 service call /slam_toolbox/save_map slam_toolbox/srv/SaveMap 
	"name: data: 'map_name'"
\end{verbatim}

\subsection{Aufgabe 4}

Um die autonome Navigation des TurtleBot 4 zu ermöglichen, wurden zunächst die notwendigen ROS 2 Launch-Dateien gestartet:

\begin{verbatim}
	ros2 launch turtlebot4_navigation localization.launch.py map:=map_name.yaml
	ros2 launch turtlebot4_navigation nav2.launch.py
	ros2 launch turtlebot4_viz view_robot.launch.py
\end{verbatim}

Damit wird die zuvor aufgezeichnete Karte in RViz geladen und gleichzeitig der Nav2-Stack inklusive Lokalisierung aktiviert.  
Anschließend wurde mit der RViz-Funktion \textit{2D Pose Estimate} die ungefähre Startposition des Roboters angegeben.  
Über die Funktion \textit{Nav2 Goal} wurde daraufhin ein Zielpunkt in der Karte gesetzt.

Nach dem Setzen des Ziels beginnt der Roboter automatisch mit der Pfadplanung und Navigation in Richtung des angegebenen Punktes. Dabei wich er Hindernissen selbstständig aus. In unserem Versuch musste der Roboter zunächst ein Stück in die entgegengesetzte Richtung fahren, bevor er die optimale Route zum Ziel nahm. Beim Erreichen des Ziels drehte er sich zweimal um die eigene Achse, was typisch für den Nav2-Controller ist, da der Roboter am Endpunkt orientiert wird.

Während der Fahrt kam es mehrfach zu kurzen Stopps. Diese entstehen, wenn der Roboter seine Sensordaten mit der Karte abgleicht und seine Trajektorie aktualisiert.  
Ein Beispiel der Navigation in RViz mit der geplanten Route ist in Abbildung \ref{fig:map2} dargestellt.

\begin{figure}[h]
	\centering
	\includegraphics[width=\textwidth]{Bilder/Driving_map.png}
	\caption{Navigation auf der Karte in RViz}
	\label{fig:map2}
\end{figure}


\subsection{Aufgabe 5}

Als letzte Aufgabe sollte eine eigene Anwendung umgesetzt werden.
Hierzu wurde das zuvor für den selbstgebauten Roboter entwickelte ROS-2-Programm übernommen und an die Struktur des TurtleBot angepasst.

Anstelle der einfachen Bumper-Signale aus der ESP32-Übung wurde für diese Aufgabe das
TurtleBot4 eigene Topic \texttt{/hazard\_detection} verwendet. Dieses Topic publiziert
Nachrichten des Typs \texttt{HazardDetectionVector}, welcher eine Liste verschiedener
Ereignisse enthält (u.a. Bumper, Cliff-Sensoren, Wheel Drop). Für das hier umgesetzte
Verhalten wurden ausschließlich die Bumper-Ereignisse ausgewertet.

Jedes Element der detections-Liste besitzt ein Typfeld sowie einen zugehörigen
Frame-Namen (z.B. \texttt{base\_left\_bumper} oder \texttt{base\_right\_bumper}).  
Die Bumper-Erkennung erfolgt, indem alle enthaltenen Ereignisse iteriert und diejenigen
ausgewählt werden, deren Typ dem Bumper-Sensor entspricht. Anhand des Frame-Namens wird
zwischen linkem und rechtem Bumper unterschieden. Dadurch konnte das zuvor
verwendete einfache ESP32-Signal durch die integrierten TurtleBot-Sensoren ersetzt werden.


Auch die Ansteuerung des Buzzers musste gegenüber den vorherigen Aufgaben angepasst
werden. Der TurtleBot4 akzeptiert keine einfachen numerischen Befehle, sondern erwartet
eine Nachricht des Typs \texttt{AudioNoteVector}. Dieses Format besteht aus einer Liste
von \texttt{AudioNote}-Einträgen, wobei jeder Eintrag eine Frequenz sowie eine maximale
Abspieldauer enthält.

Für die Umsetzung wurde beim Erkennen eines Bumper-Events programmgesteuert ein
entsprechender Ton erzeugt und als \texttt{AudioNoteVector} publiziert. Dabei wurde ein wie zuvor ein
unterschiedlicher Ton für linken und rechten Bumper verwendet. Zusätzlich erzeugt der
Roboter während des automatischen Rückwärtsfahrens mehrere kurze Signaltöne, um das
Manöver akustisch kenntlich zu machen.

Der angepasste Code ist vollständig im GitHub-Repository dokumentiert.
Das grundlegende Verhalten:

\begin{itemize}
	\item Standard: Roboter fährt langsam geradeaus.
	\item Linker Bumper: kurzer Rückwärtsgang, Drehung nach rechts, hoher Ton.
	\item Rechter Bumper: kurzer Rückwärtsgang, Drehung nach links, tiefer Ton.
	\item Beim Rückwärtsfahren zu beginn: periodischer Warnton.
\end{itemize}

Die Fahrdistanzen und Drehungen wurden verkürzt.

Die Anpassung funktionierte gut.
Der TurtleBot führte das Ereignis-basierte Verhalten zuverlässig aus:

\begin{itemize}
	\item Die Hazard-Detection erkannte Kollisionen korrekt.
	\item Buzzer-Signale wurden wie vorgesehen ausgeführt.
	\item Rückwärtsfahrt und Drehmanöver liefen stabil.
	\item Kurze Stopps oder minimale Verzögerungen entstanden durch Nachrichtenschwankungen, hatten jedoch keinen Einfluss auf das Gesamtverhalten.
\end{itemize}

Insgesamt zeigte sich, dass ein zuvor entwickeltes ROS-2-Programm mit wenigen Änderungen erfolgreich auf einen professionellen Roboter portiert werden kann, sofern Topics und Nachrichtenformate entsprechend angepasst werden.
